---
description: Python and FastAPI best practices for backend files
globs: *.py
---

# Python File Rules


## Обязательные требования

### PEP 8 Compliance

- **Отступы**: 4 пробела (не табы)
- **Длина строки**: максимум 88 символов
- **Именование**:
  - Файлы: `snake_case` (`node_service.py`, `auth_router.py`)
  - Классы: `PascalCase` (`NodeService`, `AuthRouter`)
  - Функции и переменные: `snake_case` (`get_node_by_id`, `node_data`)
  - Константы: `UPPER_SNAKE_CASE` (`MAX_PAGE_SIZE`, `DEFAULT_TIMEOUT`)

### Type Hints

- Всегда используй type hints для функций и методов
- Используй `T | None` для значений, которые могут быть `None` (вместо `Optional[T]`)
- Используй встроенные типы `list[T]`, `dict[K, V]` для коллекций
- Используй `tuple[T, ...]` для кортежей
- Для сложных типов можно использовать `typing` модуль, но предпочитай встроенный синтаксис
- Используй Literal для описания аргументов, у которых может быть несколько допустимых значений

```python
async def get_node(node_id: str) -> NodeData | None:
    pass

async def get_nodes(
    node_type: str | None = None,
    page: int = 1
) -> list[NodeData]:
    pass
```

### FastAPI Endpoints

- Используй `APIRouter` для группировки endpoints
- Всегда указывай `response_model` для типизированных ответов
- Используй правильные HTTP статус коды из `fastapi.status`
- Следуй структуре из `docs/requirements/API_Methods_Summary.md`

```python
from fastapi import APIRouter, Depends, HTTPException, status, Query

router = APIRouter(prefix="/api/v1/nodes", tags=["nodes"])

@router.get("", response_model=list[NodeResponse], status_code=status.HTTP_200_OK)
async def get_nodes(
    node_type: str | None = Query(None, description="Фильтр по типу узла"),
    page: int = Query(1, ge=1, description="Номер страницы"),
    page_size: int = Query(10, ge=1, le=100, description="Размер страницы"),
    current_user: User = Depends(get_current_user)
) -> list[NodeResponse]:
    pass
```

### Pydantic Models

- Используй Pydantic v2 для валидации
- Создавай отдельные модели для request и response
- Используй `Field()` для валидации и документации
- Применяй валидаторы для сложной логики

```python
from pydantic import BaseModel, Field, field_validator

class CreateNodeRequest(BaseModel):
    type: str = Field(..., min_length=1, description="Тип узла")
    position: dict[str, float] = Field(..., description="Позиция узла")
    properties: dict[str, any] | None = Field(default_factory=dict)
    
    @field_validator('position')
    @classmethod
    def validate_position(cls, v: dict[str, float]) -> dict[str, float]:
        if 'x' not in v or 'y' not in v:
            raise ValueError('Position must contain x and y coordinates')
        return v

class NodeResponse(BaseModel):
    id: str
    type: str
    position: dict[str, float]
    properties: dict[str, any]
```

### Async/Await

- Используй `async/await` для всех I/O операций
- Не используй синхронные операции в async функциях без необходимости
- Используй `asyncio.gather()` для параллельных операций

```python
async def get_node_with_edges(node_id: str) -> NodeWithEdges:
    node, edges = await asyncio.gather(
        node_service.get_by_id(node_id),
        edge_service.get_by_node_id(node_id)
    )
    return NodeWithEdges(node=node, edges=edges)
```

### Dependency Injection

- Используй `Depends()` для переиспользуемой логики
- Создавай dependencies для аутентификации и авторизации
- Разделяй бизнес-логику на сервисы

```python
from fastapi import Depends

async def get_current_user(
    token: str = Depends(oauth2_scheme)
) -> User:
    # проверка токена и получение пользователя
    pass

@router.get("/profile")
async def get_profile(
    current_user: User = Depends(get_current_user)
):
    return current_user
```

### Исключения

#### Иерархия исключений

В проекте используется иерархия кастомных исключений из `app.exceptions`:

- **`BusinessLogicError`** - базовый класс для всех бизнес-логических ошибок
  - `AuthenticationError` (401) - ошибки аутентификации
  - `AuthorizationError` (403) - ошибки авторизации
  - `NotFoundError` (404) - ресурс не найден
  - `ConflictError` (409) - конфликт ресурсов
  - `ValidationError` (400) - ошибки валидации
  - `DatabaseError` (500) - ошибки работы с БД

Все исключения имеют атрибуты `detail` (сообщение) и `status_code` (HTTP код).

#### Когда использовать кастомные исключения vs HTTPException

**Используй кастомные исключения (`BusinessLogicError` и его подклассы):**
- В **сервисном слое** (`services/`) для бизнес-логики
- В **dependencies** для проверки прав доступа
- Когда ошибка может быть обработана на разных уровнях
- Когда нужно разделить бизнес-логику и HTTP представление

**Используй `HTTPException` напрямую:**
- В **роутерах** только в особых случаях (например, для безопасности - скрытие деталей)
- Когда нужна специфическая обработка HTTP заголовков
- Когда ошибка специфична для HTTP слоя

#### Использование исключений в разных слоях

**1. Сервисный слой (`services/`)**

В сервисах всегда используй кастомные исключения из `app.exceptions`. Сервисы не должны знать о HTTP.

```python
from app.exceptions import (
    UserNotFoundError,
    EmailAlreadyExistsError,
    InvalidFormatError,
)

async def get_user_by_id(
    db: AsyncSession,
    user_id: uuid.UUID
) -> User | None:
    """
    Get user by ID.
    
    Returns:
        User if found, None otherwise
    
    Raises:
        UserNotFoundError: If user not found (если требуется обязательное наличие)
    """
    result = await db.execute(select(User).where(User.id == user_id))
    user = result.scalar_one_or_none()
    
    if user is None:
        raise UserNotFoundError(str(user_id))
    
    return user

async def create_user(
    db: AsyncSession,
    email: str,
    name: str,
    password_hash: str,
) -> User:
    """
    Create a new user.
    
    Raises:
        EmailAlreadyExistsError: If email already exists
        InvalidFormatError: If email format is invalid
    """
    # Проверка уникальности email
    existing = await get_user_by_email(db, email)
    if existing is not None:
        raise EmailAlreadyExistsError(email)
    
    # Создание пользователя
    new_user = User(email=email, name=name, password_hash=password_hash)
    db.add(new_user)
    await db.flush()
    return new_user
```

**2. Роутеры (`routers/`)**

В роутерах **не нужно** оборачивать исключения из сервисов в `HTTPException`. Middleware автоматически конвертирует `BusinessLogicError` в HTTP ответы. Просто пробрасывай исключения дальше.

```python
from app.exceptions import InvalidFormatError, UserNotFoundError
from app.services.user_service import get_user_by_id

@router.get("/users/{user_id}", response_model=UserResponse)
async def get_user(
    user_id: str,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
) -> UserResponse:
    """
    Get user by ID.
    
    Raises:
        InvalidFormatError: If user ID format is invalid
        UserNotFoundError: If user not found
        UserAccessDeniedError: If access denied
    """
    # Валидация формата UUID
    try:
        user_uuid = uuid.UUID(user_id)
    except (ValueError, TypeError):
        raise InvalidFormatError(f"Неверный формат ID пользователя: {user_id}")
    
    # Проверка прав доступа
    if current_user.id != user_uuid and current_user.role != UserRole.ADMIN:
        raise UserAccessDeniedError()
    
    # Вызов сервиса - исключения пробрасываются автоматически
    user = await get_user_by_id(db, user_uuid)
    # Если user is None, сервис выбросит UserNotFoundError
    
    return UserResponse.from_user(user)
```

**Исключение:** В роутерах можно использовать `HTTPException` напрямую для случаев, когда нужно скрыть детали ошибки (например, в аутентификации):

```python
@router.post("/login")
async def login(request: LoginRequest, db: AsyncSession = Depends(get_db)):
    """
    Login endpoint.
    
    Используем HTTPException для безопасности - не раскрываем,
    существует ли пользователь с таким email.
    """
    user = await get_user_by_email(db, request.email)
    
    # Генерируем общее сообщение для обоих случаев
    generic_error = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Неверный email или пароль.",
    )
    
    if user is None or not verify_password(request.password, user.password_hash):
        raise generic_error
    
    # ... создание токена
```

**3. Dependencies (`dependencies/`)**

В dependencies используй кастомные исключения для проверки прав доступа:

```python
from app.exceptions import TokenMissingError, TokenInvalidError, RoleAccessDeniedError

async def get_current_user(
    token: str = Depends(oauth2_scheme),
    db: AsyncSession = Depends(get_db),
) -> User:
    """
    Get current authenticated user from JWT token.
    
    Raises:
        TokenMissingError: If token is missing
        TokenInvalidError: If token is invalid or expired
        UserNotFoundError: If user from token not found
    """
    if not token:
        raise TokenMissingError()
    
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id = payload.get("sub")
        if not user_id:
            raise TokenInvalidError()
    except jwt.ExpiredSignatureError:
        raise TokenExpiredError()
    except jwt.JWTError:
        raise TokenInvalidError()
    
    user = await get_user_by_id(db, uuid.UUID(user_id))
    if user is None:
        raise UserNotFoundError(user_id)
    
    return user

def require_role(allowed_roles: list[UserRole]):
    """
    Dependency to check if user has required role.
    
    Raises:
        RoleAccessDeniedError: If user doesn't have required role
    """
    async def role_checker(current_user: User = Depends(get_current_user)) -> None:
        if current_user.role not in allowed_roles:
            raise RoleAccessDeniedError()
        return None
    
    return role_checker
```

#### Обработка исключений через middleware

Все `BusinessLogicError` автоматически обрабатываются middleware (`app.middleware.exception_handlers`):

- `BusinessLogicError` → конвертируется в HTTP ответ с соответствующим `status_code`
- `HTTPException` → обрабатывается стандартным обработчиком
- `PydanticValidationError` → обрабатывается специальным обработчиком (422)
- Неожиданные исключения → логируются и возвращается 500

**Не нужно** вручную оборачивать исключения в `HTTPException` в роутерах, если они уже являются `BusinessLogicError`.

#### Лучшие практики

1. **Всегда документируй исключения в docstrings:**
```python
async def create_node_mart(
    db: AsyncSession,
    request: CreateNodeMartRequest,
) -> NodeMart:
    """
    Create a new node mart.
    
    Raises:
        InvalidFormatError: If nodeTypeKey format is invalid
        NodeMartKeyAlreadyExistsError: If nodeTypeKey already exists
        SchemaNotFoundError: If schema doesn't exist
        TableAlreadyExistsError: If table already exists
        TableCreationError: If table creation fails
    """
```

2. **Всегда используй русский язык для сообщений об ошибках:**
```python
# ✅ Правильно - сообщения на русском
raise UserNotFoundError(user_id)  # "Пользователь с ID {user_id} не найден."
raise EmailAlreadyExistsError(email)  # "Пользователь с таким email уже существует."
raise InvalidFormatError("Неверный формат ID пользователя")
raise MartAccessDeniedError()  # "Доступ запрещен. У вас нет доступа к этой витрине."

# ❌ Избегай - сообщения на английском
raise UserNotFoundError(f"User {user_id} not found")
raise EmailAlreadyExistsError(f"User with email {email} already exists")
raise InvalidFormatError("Invalid user ID format")
```

**Важно:** Все сообщения об ошибках, которые видят пользователи через API, должны быть на русском языке. Это касается:
- Сообщений в исключениях (`detail` параметр)
- Сообщений в `HTTPException` для пользователей
- Логирование может быть на английском для разработчиков

3. **Используй конкретные исключения, а не общие:**
```python
# ✅ Правильно
if user is None:
    raise UserNotFoundError(user_id)

# ❌ Избегай
if user is None:
    raise NotFoundError(f"User {user_id} not found")
```

4. **Не используй голый `except:`:**
```python
# ✅ Правильно
try:
    result = await some_operation()
except SpecificError as e:
    logger.error(f"Specific error: {e}")
    raise
except Exception as e:
    logger.error(f"Unexpected error: {e}", exc_info=True)
    raise DatabaseOperationError("Операция не удалась")

# ❌ Избегай
try:
    result = await some_operation()
except:  # Слишком широкий перехват
    raise
```

5. **Логируй ошибки перед их пробрасыванием:**
```python
# ✅ Правильно
try:
    await complex_operation()
except BusinessLogicError as e:
    logger.warning(f"Business logic error: {e.detail}")
    raise  # Пробрасываем дальше
except Exception as e:
    logger.error(f"Unexpected error: {e}", exc_info=True)
    raise DatabaseOperationError("Операция не удалась")
```

6. **Используй `from` для цепочки исключений:**
```python
# ✅ Правильно
try:
    await db.execute(query)
except SQLAlchemyError as e:
    raise DatabaseOperationError("Не удалось выполнить запрос") from e
```

7. **Не обрабатывай исключения, которые не можешь обработать:**
```python
# ✅ Правильно - пробрасываем исключение дальше
async def get_node(node_id: str) -> Node:
    node = await node_service.get_by_id(node_id)
    # Если node is None, сервис выбросит NodeNotFoundError
    # Мы просто пробрасываем его дальше
    return node

# ❌ Избегай - не нужно оборачивать в try/except без логики
async def get_node(node_id: str) -> Node:
    try:
        node = await node_service.get_by_id(node_id)
        return node
    except NodeNotFoundError:
        raise  # Бесполезная обертка
```

### Структура модулей

- Разделяй код на логические модули: `routers/`, `models/`, `services/`, `utils/`
- Используй `__init__.py` для организации пакетов
- Создавай отдельные файлы для роутеров по функциональности

```
backend/
├── app/
│   ├── routers/
│   │   ├── __init__.py
│   │   ├── auth.py
│   │   ├── nodes.py
│   │   └── edges.py
│   ├── models/
│   │   ├── __init__.py
│   │   ├── user.py
│   │   └── node.py
│   ├── services/
│   │   ├── __init__.py
│   │   ├── node_service.py
│   │   └── auth_service.py
│   └── utils/
│       ├── __init__.py
│       └── dependencies.py
```

### Импорты

**КРИТИЧЕСКИ ВАЖНО: НИКОГДА не делай импорты внутри функций, методов, классов или любых других блоков кода. ВСЕ импорты должны быть на уровне модуля (в начале файла).**

#### Правила импортов

1. **ВСЕ импорты должны быть в начале файла** (после docstring модуля, если есть)
2. **НИКОГДА не делай импорты внутри функций**
3. **НИКОГДА не делай импорты внутри методов**
4. **НИКОГДА не делай импорты внутри классов**
5. **НИКОГДА не делай импорты внутри блоков try/except**
6. **НИКОГДА не делай импорты внутри условных блоков (if/else)**

#### Порядок импортов

1. Стандартная библиотека Python
2. Сторонние библиотеки
3. Локальные импорты

Между группами импортов должна быть пустая строка.

```python
# ✅ Правильно - все импорты в начале файла
# Стандартная библиотека
from pathlib import Path
from typing import Optional
import uuid

# Сторонние библиотеки
from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel, Field
from sqlalchemy.ext.asyncio import AsyncSession

# Локальные импорты
from app.models.user import User
from app.services.node_service import NodeService
from app.exceptions import UserNotFoundError

# Теперь код функций
async def get_user(user_id: str) -> User:
    # ...
    pass
```

```python
# ❌ НИКОГДА не делай так - импорт внутри функции
async def get_user(user_id: str) -> User:
    from app.models.user import User  # НЕТ! НЕТ! НЕТ!
    # ...
    pass
```

```python
# ❌ НИКОГДА не делай так - импорт внутри метода
class UserService:
    def get_user(self, user_id: str) -> User:
        from app.models.user import User  # НЕТ! НЕТ! НЕТ!
        # ...
        pass
```

```python
# ❌ НИКОГДА не делай так - импорт внутри условного блока
if some_condition:
    from app.models.user import User  # НЕТ! НЕТ! НЕТ!
```

```python
# ❌ НИКОГДА не делай так - импорт внутри try/except
try:
    from app.models.user import User  # НЕТ! НЕТ! НЕТ!
except ImportError:
    pass
```

```python
# ❌ НИКОГДА не делай так - импорт внутри класса
class UserService:
    from app.models.user import User  # НЕТ! НЕТ! НЕТ!
    
    def get_user(self, user_id: str) -> User:
        pass
```

#### Почему это важно

- **Производительность**: Импорты внутри функций выполняются каждый раз при вызове функции
- **Читаемость**: Импорты в начале файла показывают все зависимости модуля
- **PEP 8**: Соответствие стандартам Python
- **Отладка**: Легче найти проблемы с импортами, когда они в одном месте
- **Циклические зависимости**: Импорты внутри функций могут скрыть проблемы с циклическими зависимостями

#### Исключения

**Единственное допустимое исключение** - это когда нужно избежать циклических зависимостей, но даже в этом случае лучше реструктурировать код, чтобы избежать циклических зависимостей.

Если все же необходимо (крайне редко), используй `TYPE_CHECKING`:

```python
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from app.models.user import User  # Только для type hints

# В коде используй строковые аннотации
async def get_user(user_id: str) -> "User":
    from app.models.user import User  # НЕТ! Даже с TYPE_CHECKING не делай импорт внутри функции
    # ...
```

**Но лучше всего - реструктурировать код, чтобы избежать циклических зависимостей.**

### Pathlib вместо os.path

- Используй `pathlib.Path` вместо `os.path`
- Это более современный и читаемый подход

```python
from pathlib import Path

# ✅ Правильно
config_path = Path(__file__).parent / "config.json"

# ❌ Избегай
import os
config_path = os.path.join(os.path.dirname(__file__), "config.json")
```

### Порядок функций внутри модуля или класса

- публичные функции и методы
- защищенные функции и методы (один символ `_` в начале)
- приватные функции и методы (два символа `__` в начале)


### Аутентификация и авторизация

- Используй JWT токены для аутентификации
- Создавай dependency `get_current_user` для проверки токенов
- Проверяй права доступа на уровне endpoints
- Используй роли и пулы доступа согласно FR-029

## Форматирование

### Обязательная проверка ruff

**КРИТИЧЕСКИ ВАЖНО:** После каждого изменения Python файла **ОБЯЗАТЕЛЬНО** запускай ruff для проверки и исправления всех предупреждений.

#### Процесс работы с ruff

1. **После изменения файла** всегда запускай:
   ```bash
   cd backend
   uv run ruff check --fix <путь_к_файлу>
   uv run ruff format <путь_к_файлу>
   ```

2. **Проверяй все предупреждения**, особенно:
   - **Длина строки (E501, W505)** - максимум 88 символов
   - Неиспользуемые импорты (F401)
   - Неиспользуемые переменные (F841)
   - Все остальные предупреждения ruff

3. **Исправляй все предупреждения**, не оставляй их без внимания

#### Длина строки

**Особое внимание уделяй длине строки:**
- Максимум **88 символов** на строку (согласно PEP 8 и настройкам ruff)
- Если строка превышает 88 символов, **обязательно** разбивай её на несколько строк
- Используй правильные способы переноса строк:
  - Внутри скобок (функции, списки, словари)
  - Используй обратный слэш `\` только если нет другого способа
  - Используй многострочные строки для длинных текстов

```python
# ✅ Правильно - строка не превышает 88 символов
async def get_node(
    node_id: str,
    include_edges: bool = False,
) -> Node | None:
    pass

# ✅ Правильно - длинная строка разбита на несколько
error_message = (
    "Ошибка при создании узла. "
    "Проверьте правильность входных данных."
)

# ❌ Избегай - строка превышает 88 символов
async def get_node(node_id: str, include_edges: bool = False, include_properties: bool = True) -> Node | None:
    pass

# ✅ Правильно - исправленная версия
async def get_node(
    node_id: str,
    include_edges: bool = False,
    include_properties: bool = True,
) -> Node | None:
    pass
```

#### Автоматическое исправление

Ruff может автоматически исправить большинство проблем:
- `ruff check --fix` - исправляет автоматически исправимые проблемы
- `ruff format` - форматирует код согласно стилю

**Но всегда проверяй результат** - некоторые проблемы требуют ручного исправления.

#### Проверка всех файлов

Если изменено несколько файлов, можно проверить все сразу:
```bash
cd backend
uv run ruff check --fix .
uv run ruff format .
```

#### Игнорирование предупреждений

**НИКОГДА не игнорируй предупреждения ruff без веской причины.** Если нужно игнорировать предупреждение:
1. Убедись, что это действительно необходимо
2. Используй `# noqa: <код>` с конкретным кодом предупреждения
3. Добавь комментарий, объясняющий почему игнорируется

```python
# ✅ Правильно - с объяснением
# Игнорируем E501 для URL, так как его нельзя разбить
long_url = "https://very-long-url-that-cannot-be-split.com/path/to/resource"  # noqa: E501

# ❌ Избегай - без объяснения
long_url = "https://very-long-url.com"  # noqa
```

#### Чеклист после изменения файла

После каждого изменения Python файла проверь:
- [ ] Запущен `ruff check --fix` на изменённом файле
- [ ] Запущен `ruff format` на изменённом файле
- [ ] Все предупреждения исправлены (особенно длина строки)
- [ ] Код соответствует PEP 8
- [ ] Нет неиспользуемых импортов
- [ ] Нет неиспользуемых переменных



## Используемые пакеты
- для работы с датами и временем используй пакет pendulum вместо стандартного `datetime`
- для работы с JWT используйу пакет `pyjwt`
- для логирования используй пакет `loguru` вместо стандартного `logging`

## Логирование

### Использование loguru

**Всегда используй loguru для логирования**, никогда не используй стандартный модуль `logging`.

```python
# ✅ Правильно
from loguru import logger

logger.info("Operation completed")
logger.warning("Potential issue")
logger.error("Operation failed", exc_info=True)

# ❌ Избегай
import logging
logger = logging.getLogger(__name__)
```

### Уровни логирования

Используй подходящие уровни логирования:

- **DEBUG**: Детальная информация для отладки (только в development)
- **INFO**: Общая информация о работе приложения
- **WARNING**: Предупреждения о потенциальных проблемах
- **ERROR**: Ошибки, которые не останавливают приложение
- **CRITICAL**: Критические ошибки, которые могут остановить приложение

```python
# ✅ Правильно
logger.debug("Detailed debug information")
logger.info("User logged in successfully")
logger.warning("Rate limit approaching")
logger.error("Database connection failed", exc_info=True)
logger.critical("Application cannot start")
```

### Структурированное логирование

Используй `.bind()` для добавления контекста к логам:

```python
# ✅ Правильно - с контекстом
logger.bind(user_id=user.id, operation="create_node").info("Node created")

# ✅ Правильно - с дополнительными полями
logger.bind(
    request_id=request_id,
    method=request.method,
    path=request.url.path,
).info("Request processed")
```

### Защита чувствительных данных

**НИКОГДА не логируй чувствительные данные:**

- Пароли
- JWT токены
- Секретные ключи
- API ключи
- Database URLs с паролями
- Cookie значения

```python
# ❌ НИКОГДА не делай так!
logger.info(f"User password: {password}")
logger.info(f"JWT token: {token}")
logger.info(f"Database URL: {database_url}")

# ✅ Правильно
logger.info("User authenticated successfully")
logger.info("Token validated")
logger.info("Database connection established")
```

Система логирования автоматически фильтрует чувствительные данные, но лучше не логировать их вообще.

### Логирование ошибок

Всегда логируй ошибки с полной информацией:

```python
# ✅ Правильно - с полной информацией об ошибке
try:
    result = await some_operation()
except SpecificError as e:
    logger.error(f"Operation failed: {e}", exc_info=True)
    raise
except Exception as e:
    logger.error(f"Unexpected error: {e}", exc_info=True)
    raise DatabaseOperationError("Операция не удалась")
```

### Логирование в сервисах

В сервисах логируй важные операции:

```python
# ✅ Правильно
async def create_node_mart(db: AsyncSession, request: CreateNodeMartRequest) -> NodeMart:
    logger.info(f"Creating node mart with key: {request.node_type_key}")
    try:
        # ... создание витрины
        logger.info(f"Node mart created successfully: {request.node_type_key}")
        return node_mart
    except Exception as e:
        logger.error(f"Failed to create node mart: {e}", exc_info=True)
        raise
```

### Request ID Tracking

Все HTTP запросы автоматически получают уникальный `request_id`. Используй его для отслеживания запросов:

```python
# Request ID автоматически добавляется в заголовки ответа
# Используй его в логах для связи запросов
logger.bind(request_id=request_id).info("Processing request")
```

## Запись SQL запросов
- используй multi-line строки в тройных кавычках для записи статических/шаблонных SQL запросов 

